using System;
using System.Collections.Generic;
using System.Text;

namespace DevLab.JmesPath.Utils
{
    /// <summary>
    /// PushbackQueue provides the infrastructure for pushing back token 
    /// information to a host scanner. The class provides an API for 
    /// initializing new lookahead buffers and adding those to the queue.
    /// The host scanner must be modified so that yylex takes tokens from
    /// the queue while the queue is not empty.
    /// </summary>
    internal class PushbackQueue<Obj>
    {
        // 
        //  The argument for type-param Obj will be the ScanObj
        //  class generated by GPPG. Each object encapsulates --
        //    * a field "token" of type int.
        //    * a field "yylval" of TValue type.
        //    * a field "yylloc" of TSpan type.
        //

        public delegate Obj GetObj();
        public delegate Obj TokWrap(int tok);

        GetObj getObj;
        TokWrap tokWrap;

        /// <summary>
        /// Create a new pushback queue which enqueues token information 
        /// from the host scanner. This should be called once per scanner
        /// instance, at scanner initialization.
        /// </summary>
        /// <param name="getObj">A delegate that constructs an Obj from a call to scanner.yylex</param>
        /// <param name="tokWrap">A delegate that constructs an Obj from the given integer token</param>
        /// <returns>A reference to the queue object</returns>
        public static PushbackQueue<Obj> NewPushbackQueue(GetObj getObj, TokWrap tokWrap)
        {
            return new PushbackQueue<Obj>(getObj, tokWrap);
        }

        private PushbackQueue(GetObj getObj, TokWrap tokWrap)
        {
            this.getObj = getObj;
            this.tokWrap = tokWrap;
        }

        /// <summary>
        /// The current queue from which ScanObj objects are dequeued
        /// </summary>
        Queue<Obj> currentSymbolQueue;

        /// <summary>
        /// The buffer into which lookahead ScanObj are placed
        /// </summary>
        Queue<Obj> pushbackBuffer;
#if TRACE_ACTIONS
        /// <summary>
        /// Used for tracing diagnostics only.
        /// </summary>
        public int BufferLength { get { return pushbackBuffer.Count; } }
#endif

        /// <summary>
        /// The stack of pushback buffers. Whenever currentSymbolQueue
        /// is exhausted the top of this stack is popped into 
        /// currentSymbolQueue
        /// </summary>
        Stack<Queue<Obj>> allQueues = new Stack<Queue<Obj>>();
#if TRACE_ACTIONS
        /// <summary>
        /// Used for tracing diagnostics only.
        /// </summary>
        public int QueueCount { get { return allQueues.Count; } }
#endif

        /// <summary>
        /// Total number of queued symbols.
        /// </summary>
        int totalQueueLength = 0;
        public int QueueLength { get { return totalQueueLength; } }

        /// <summary>
        /// Fetch a symbol from the host scanner and enqueue.
        /// </summary>
        /// <returns>the enqueued ScanObj</returns>
        public Obj GetAndEnqueue()
        {
            Obj result;
            //
            // We could always call host.yylex(), but if the ScanObj
            // is already allocated, use it and spare the GC.
            //
            if (totalQueueLength > 0)
                result = this.DequeueCurrentToken();
            else
                result = this.getObj();
            pushbackBuffer.Enqueue(result);
            return result;
        }

        /// <summary>
        /// Fetch a ScanObj object from the enqueued symbol
        /// information, and perform queue housekeeping.
        /// </summary>
        /// <returns>the dequeued ScanObj</returns>
        public Obj DequeueCurrentToken()
        {
            Obj result = currentSymbolQueue.Dequeue();
            totalQueueLength--;
            if (currentSymbolQueue.Count == 0 && totalQueueLength > 0)
                currentSymbolQueue = allQueues.Pop();
            return result;
        }

        /// <summary>
        /// Begin a new lookahead by allocating a pushback buffer
        /// if necessary. If nextToken is zero the next symbol has
        /// not been fetched so fetch it now. 
        /// Enqueue the symbol information in the pushback buffer
        /// and return the ScanObj object.
        /// </summary>
        /// <param name="nextToken">next token, or zero if not fetched yet</param>
        /// <returns>next symbol information</returns>
        public Obj EnqueueAndReturnInitialSymbol(int token)
        {
            // Creating a new pushbackBuffer is necessary, unless
            // the last pushback buffer was abandoned and cleared.
            Obj next;
            if (pushbackBuffer == null)
                pushbackBuffer = new Queue<Obj>();
            if (token != 0)
                next = this.tokWrap(token);
            else if (totalQueueLength > 0)
                next = this.DequeueCurrentToken();
            else
                next = this.getObj();
            this.pushbackBuffer.Enqueue(next);
            return next;
        }

        /// <summary>
        /// Add pushback buffer to the token queue
        /// </summary>
        public void AddPushbackBufferToQueue()
        {
            // Stack previous currentSymbolQueue if notEmpty, and
            // make currentSymbolQueue reference the pushback buffer.
            if (currentSymbolQueue != null && currentSymbolQueue.Count > 0)
                allQueues.Push(currentSymbolQueue);
            currentSymbolQueue = pushbackBuffer;
            totalQueueLength += pushbackBuffer.Count;
            pushbackBuffer = null;
        }

        /// <summary>
        /// Abandon the current length-1 pushback buffer.
        /// The parser NextToken field must have been restored!
        /// </summary>
        public void AbandonPushback()
        {
            this.pushbackBuffer.Clear();
        }
    }
}
